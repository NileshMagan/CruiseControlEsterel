
% TODO: cruiseEnable
% TODO brakePressed signal

% TODO double check cruiseEnable
% TODO may need to pre(brakePressed)
% TODO check if defaulting inputs to 0 is bad
module FSM:
function regulateThrottle(boolean, float, float): float;

	%Interface declarations
	input on, off, resume, set;
	input brakePressed;
	input cruiseEnable;
	input speed : float;
	input accel : float;
	input cruiseSpeed : float;

	output throttleCmd : float;
	output cruiseState : integer; 

		var prevState := 1 : integer, state := 1 : integer in
			loop
				trap T1 in
					pause; 		% TICK DEPENDANT 

					if (state = 1) then 			% OFF
						%%%% NEXT STATE LOGIC
						present on then
							state := 2;
						end present;
					
						exit T1;
					end if;
				
					if (state = 2) then			% ON
						%%%% NEXT STATE LOGIC
						present off then
							state := 1;
							exit T1;
						end present;
						present brakePressed then
							state := 3;
							exit T1;
						end present;
						present not(cruiseEnable) then
							state := 4;
							exit T1;
						end present;
					
						exit T1;
					end if;
							
					if (state = 3) then			% STDBY
						%%%% NEXT STATE LOGIC
						present off then
							state := 1;
							exit T1;
						end present;
						
						present resume and cruiseEnable then
							state := 2; 
							exit T1;
						end present;
						present resume and not(cruiseEnable) then
							state := 4;
							exit T1;				
						end present;
						
						exit T1;
					end if;

					if (state = 4) then			% DISABLE
						%%%% NEXT STATE LOGIC
						present off then
							state := 1;
							exit T1;
						end present;
						present cruiseEnable then
							state := 2;
							exit T1;
						end present;
					
						exit T1;
					end if;

				end trap;
				
				%%%% OUTPUT LOGIC
				emit cruiseState(state);
				if (state = 2) then
					if (prevState = 2) then
						emit throttleCmd(regulateThrottle(false, ?cruiseSpeed, ?speed));
					else
						emit throttleCmd(regulateThrottle(true, ?cruiseSpeed, ?speed));
					end if;
				else % If not in ON state, throttleCmd <= accel
					emit throttleCmd(?accel);
				end if;

				prevState := state;

			end loop		
		end var
end module	
	

module brakeDetection: %%%%%%%% BRAKE PRESS DETECTION
	input brake : float;
	output brakePressed;
	constant pedalsMin = 3.0f : float;
	
		loop
			% TODO check if this should be pre or not
			await brake;
			if (?brake > pedalsMin) then
				emit brakePressed
			end if;
		end loop
end module


module accelDetection: %%%%%%%% ACCEL PRESS DETECTION
	input accel : float;
	output accelPressed;
	constant pedalsMin = 3.0f : float;
		loop
			% TODO check if this should be pre or not
			await accel;
			if (?accel > pedalsMin) then
				emit accelPressed
			end if;
		end loop
end module

module speedLimitDetection: %%%%%%%% CALC WITHIN SPEED LIMIT
	input speed : float;
	output withinSpeedLimit;
	constant speedMin  = 30.0f   : float;
	constant speedMax  = 150.0f  : float;
		loop 
			if (?speed > speedMin) and (?speed < speedMax) then 
				emit withinSpeedLimit
			end if;
			pause
		end loop 
end module
	

module cruiseEnableDetection: %%%%%%%% CALC CRUISE ENABLE
	input accelPressed, withinSpeedLimit;
	output cruiseEnable;
		loop 
			%TODO, may need a pre here
			present (not accelPressed) and withinSpeedLimit then 
				emit cruiseEnable;
			end present;
			pause
		end loop
end module


module cruiseSpeedManagement: %%%%%%%% CRUISE SPEED MANAGEMENT 
	input on, set, withinSpeedLimit, accelPressed, quickAccel, quickDeccel;
	input speed : float;
	output cruiseSpeed : float;
	constant speedMin  = 30.0f   : float;
	constant speedMax  = 150.0f  : float;
	constant speedInc  = 2.5f    : float;
		loop
			% TODO: Likely need a pre here too
			present (on or set) and withinSpeedLimit then 
				sustain cruiseSpeed(?speed);
			end present; 
		
			present quickAccel then 
				if ((?speed + speedInc) < speedMax) then 
					emit speed(?speed + speedInc);
				end if;
			end present; 

			present quickDeccel then 
				if ((?speed - speedInc) > speedMin) then 
					emit speed(?speed - speedInc);
				end if;
			end present;
			%TODO: pause what we want here?
			pause
		end loop
end module
	
%||
%
%	[ %%%%%%%% DRIVING CONTROL
%		var currentThrottle := 0 : float in	
%			loop 
%				% TODO: may need pre here
%				present (not off) then
%					present (on) then 
%						if (pre(not on)) then
%							regulateThrottle(true, ?cruiseSpeed, ?speed);
%						else
%							regulateThrottle(false, ?cruiseSpeed, ?speed);
%						end if;
%					end present; 	
%				end present;
%				pause 
%			end loop 
%		end var
%	]
	
module cruiseControl:
	%interface declarations
	input on, off, resume, set, quickDeccel, quickAccel;
	input accel := 0.0f : float;
	input brake := 0.0f : float;
	input speed := 0.0f : float;

	output cruiseSpeed := 0.0f : float;
	output throttleCmd := 0.0f : float;
	output cruiseState := 1: integer;


	signal accelPressed, brakePressed, cruiseEnable, withinSpeedLimit in
		run FSM[ 
			signal on/on;
			signal off/off;
			signal resume/resume;
			signal brakePressed/brakePressed;
			signal cruiseEnable/cruiseEnable;
			signal speed/speed;
			signal accel/accel;
			signal cruiseSpeed/cruiseSpeed;
			signal throttleCmd/throttleCmd;
			signal cruiseState/cruiseState
		]
		||
		run brakeDetection[ 
			signal brake/brake;
			signal brakePressed/brakePressed
		]
		||
		run accelDetection[ 
			signal accel/accel;
			signal accelPressed/accelPressed 
		]
		||
		run speedLimitDetection[ 
			signal speed/speed;
			signal withinSpeedLimit/withinSpeedLimit 
		]
		||
		run cruiseEnableDetection[ 
			signal accelPressed/accelPressed;
			signal withinSpeedLimit/withinSpeedLimit; 
			signal cruiseEnable/cruiseEnable
		]
		||
		run cruiseSpeedManagement[ 
			signal on/on;
			signal set/set;
			signal withinSpeedLimit/withinSpeedLimit; 
			signal accelPressed/accelPressed;
			signal quickAccel/quickAccel;
			signal quickDeccel/quickDeccel;
			signal speed/speed;
			signal cruiseSpeed/cruiseSpeed
		]
        end signal;
end module


